const quantifiers = {
  '+': true
}
const respect = {
  a: true,
  0: true,
  '?': true
}

const nextRegexes = {
  a: /^([a-zA-Z]+)/,
  0: /^(\d+)/,
  'xxx?': /.+/
}
const previousRegexes = {
  a: /([a-zA-Z]+)$/,
  0: /(\d+)$/,
  'xxx?': /.+/
}

const getOutputChar = (char, patternChar, options = {}) => {
  if (options.ignore && options.ignore.includes(char)) {
    return char
  }
  return respect[patternChar] ? char : patternChar
}

let processValueWithPattern = ({value = '', pattern = '', outputfront = '', outputback = ''}, options = {}) => {
  const nextPatternChar = pattern.charAt(1)
  const lastPatternChar = pattern.charAt(pattern.length - 1)
  if (value) {
    if (!nextPatternChar || !quantifiers[nextPatternChar]) {
      const currentPatternChar = pattern.charAt(0)
      const outputChar = getOutputChar(value.charAt(0), currentPatternChar, options)
      outputfront += outputChar
      value = value.substr(1)
      pattern = pattern.substr(1)
      const processed = processValueWithPattern({value, pattern, outputfront, outputback}, options)
      value = processed.value
      pattern = processed.pattern
      outputfront = processed.outputfront
      outputback = processed.outputback
    } else if (!quantifiers[lastPatternChar]) {
      const outputChar = getOutputChar(value.charAt(value.length - 1), lastPatternChar, options)
      outputback = outputChar + outputback
      value = value.substr(0, value.length - 1)
      pattern = pattern.substr(0, pattern.length - 1)
      const processed = processValueWithPattern({value, pattern, outputfront, outputback}, options)
      value = processed.value
      pattern = processed.pattern
      outputfront = processed.outputfront
      outputback = processed.outputback
    } else if (quantifiers[nextPatternChar]) {
      const replaceChar = pattern.charAt(0)
      const nextChar = pattern.charAt(2)
      if (nextChar) {
        if (nextRegexes[replaceChar]) {
          value = value.replace(nextRegexes[replaceChar], (m, m1) => {
            outputfront += m1
            return ''
          })
          pattern = pattern.substr(2)
          const processed = processValueWithPattern({value, pattern, outputfront, outputback}, options)
          value = processed.value
          pattern = processed.pattern
          outputfront = processed.outputfront
          outputback = processed.outputback
        } else {
          const replacePrevChar = pattern.charAt(pattern.length - 2)
          if (nextRegexes[replacePrevChar]) {
            value = value.replace(previousRegexes[replacePrevChar], (m, m1) => {
              outputback = m1 + outputback
              return ''
            })
            pattern = pattern.substr(0, pattern.length - 2)
            const processed = processValueWithPattern({value, pattern, outputfront, outputback}, options)
            value = processed.value
            pattern = processed.pattern
            outputfront = processed.outputfront
            outputback = processed.outputback
          } else {
            // pattern makes no sense
            outputfront += value.replace(/./g, replaceChar)
            value = ''
          }
        }
      } else {
        // final multi-char to match
        let outputChars = value
        value = ''
        if (options.minLength) {
          const padChar = '*' // respect[replaceChar] ? replaceChar : '*'
          while (outputChars.length < options.minLength) {
            outputChars += padChar
          }
        }
        if (!respect[replaceChar]) {
          let replaceRegexStr = options.ignore ? `[^${options.ignore.join('')}]` : '.'
          const replaceRegex = new RegExp(replaceRegexStr, 'g')
          outputChars = outputChars.replace(replaceRegex, replaceChar)
        }
        outputfront += outputChars
      }
    }
  }
  let output = ''
  if (!value) {
    output = outputfront + outputback
  }
  if (options.minLength) {
    let replaceChar = '*'
    if (pattern.length === 2 && pattern.charAt(1) === '+') {
      replaceChar = pattern.charAt(0)
    }
    while (output.length < options.minLength) {
      output += replaceChar
    }
  }
  return {
    output,
    outputfront,
    outputback,
    value,
    pattern
  }
}

const redact = (value, pattern, options = {}) => {
  if (!pattern) {
    return value
  }
  if (pattern.length === 1) {
    pattern += '+'
  }
  let {output} = processValueWithPattern({
    value,
    pattern
  }, options)
  if (output.length < value.length) {
    let replaceChar = pattern.charAt(0) || '*'
    if (pattern.length === 2 && pattern.charAt(1) === '+') {
      replaceChar = pattern.charAt(0)
    }
    output = value.replace(/./g, replaceChar)
  }
  return output
}

module.exports = redact
